use std::{
    fs::{create_dir, read},
    path::PathBuf,
    process::{Command, Stdio},
};

fn execute(cmd: &mut Command) -> bool {
    cmd.stdout(Stdio::null())
        .status()
        .unwrap_or_else(|_| panic!("failed to run the command: {:?}", cmd))
        .success()
}

fn test(id: &str, args: &[String]) {
    let ref_dir = PathBuf::from("./tests/reference");
    let actual_dir = PathBuf::from("./tests/actual");
    let reference = ref_dir.join([id, ".png"].concat());
    let actual = actual_dir.join([id, ".png"].concat());
    if reference.exists() {
        let _ = create_dir(actual_dir);
        assert!(execute(
            Command::new("./target/release/graph")
                .args(args)
                .arg("-o")
                .arg(actual.clone()),
        ));
        let reference = read(reference).unwrap();
        let actual = read(actual).unwrap();
        // Use `assert!` instead of `assert_eq!` to avoid the `Vec`s to be printed.
        assert!(reference == actual);
    } else {
        assert!(execute(
            Command::new("./target/release/graph")
                .args(args)
                .arg("-o")
                .arg(reference),
        ));
    }
}

macro_rules! t {
    ($id:ident, $($arg:expr),+) => {
        #[test]
        fn $id() {
            let id = stringify!($id);
            let args = vec![$($arg.into()),+];
            test(id, &args);
        }
    };
}

t!(t_9141185741e3473bafdd4fbd69daacb0, "y = abs(x)");
t!(t_3424e84276854880bfbaf722a55f4083, "y = acos(x)");
t!(t_37f5ce66894a4b94a578df440066cf19, "y = acosh(x)");
t!(t_38eec1c4b37442ce82c57cca99f36e81, "y = Ai(x)");
t!(t_df6c0b5de0cb45beb1dfe37e25b5c3ba, "y = Ai'(x)");
t!(t_e46074d3fb3d4876aa7cde273ded0a34, "y = asin(x)");
t!(t_9301c82b5f894f16b9b5122c09221aee, "y = asinh(x)");
t!(t_0444c061f4974171a76c9726967ecdd4, "y = atan(x)");
t!(t_d0cb560e76f64a2c96b51cc659192105, "y = atanh(x)");
t!(t_0dd58ad0988349c3bf70719d5db1b195, "y = Bi(x)");
t!(t_99d818f7f192402a9c7579b1e3bda62b, "y = Bi'(x)");
t!(t_a5daa83f3ba6452694b8dc31989e49a5, "y = C(x)");
t!(t_e2432ca1dca74defb99c089a7d232eeb, "y = ceil(x)");
t!(t_3c8809b76d304630b6bb047ed44c3c84, "y = Chi(x)");
t!(t_4e6cef6277de458aa116679f52721b31, "y = cos(x)");
t!(t_ed14cf332fd64c8398d072b14dd93d54, "y = cosh(x)");
t!(t_627f51aa56d14309b527f2a37b6368e5, "y = E(x)");
t!(t_db337020ebbb4d4f82d930d38c09ee7c, "y = Ei(x)");
t!(t_ae7ed0eb236e4e579b04aadf26a2d767, "y = erf(x)");
t!(t_99de97a06c824edfbccd3e425633a290, "y = erfi(x)");
t!(t_944c89064a004af9bcda883f98785d4c, "y = exp(x)");
t!(t_0d3db3fb75604b85893ef6935b6f6ce8, "y = floor(x)");
t!(t_4e62c6b2dc704f47a8275b5f412b6f6c, "y = Gamma(x)");
t!(t_4f6d9c9c7b8d484993cb265a88322897, "y = K(x)");
t!(t_a1781b46eb8c45f58d656f455677c84c, "y = li(x)");
t!(t_6c486f3c2aef49dead6acd55f3848433, "y = ln(x)");
t!(t_0e998089005f4afda4752098d63cd55a, "y = psi(x)");
t!(t_a99a60361a8d4b69a1461484c0622e10, "y = S(x)");
t!(t_15e48b4aa9864b56bc295596008ced2f, "y = sgn(x)");
t!(t_c6e28ae9902e4517885c39c5c776e26a, "y = Shi(x)");
t!(t_b9fb18d5692e4ae6ab6e011ee31e32e6, "y = sin(x)");
t!(t_5ac006668e084891a8394362499446ea, "y = sinh(x)");
t!(t_58ee894ce5fb4164ac0e3c422ac7948f, "y = sqrt(x)");
t!(t_51f6423ada6a45eba368eb03b57e10ee, "y = tan(x)");
t!(t_c88349f5b4a74502b82b56c56ffd9ea7, "y = tanh(x)");

// NOTES:
// - Assign each test with a UUID (v4).
// - You must run `cargo b --release --all-features` before testing.
// - You can time each test with `cargo t --test graph -- -Zunstable-options --report-time`.
